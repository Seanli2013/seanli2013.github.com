
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>{} - 大钟威武</title>
<meta name="author" content="大钟威武">




<meta name="description" content="{}">

<meta name="keywords" content=" ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="http://bigbelldev.com">
<meta property="og:title" content="{}">
<meta property="og:description" content="{}">

  <meta property="og:image" content="">

<meta property="og:site_name" content="大钟威武">

<link rel="canonical" href="http://bigbelldev.com">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/atom.xml" rel="alternate" title="大钟威武" type="application/atom+xml">

<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
<script>Modernizr || document.write('<script src="/javascripts/vendor/modernizr-2.6.2.custom.min.js"><\/script>') </script>



<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


</head>

<body id="post-index" >
  <!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
  <nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="" alt="大钟威武 photo" class="author-photo">
					<h4>大钟威武</h4>
					<p></p>
				</li>
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/categories/">All Categories</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


  <div class="entry-header">
    
    
    <div class="header-title">
      <div class="header-title-wrap">
        <h1>大钟威武</h1>
        <h2>嘿嘿嘿</h2>
      </div><!-- /.header-title-wrap -->
    </div><!-- /.header-title -->
  </div><!-- /.entry-header -->

  <div id="main" role="main">
    

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2021-03-31T10:13:21+08:00">
        <a href="/blog/2021/03/31/hello-again/">March 31, 2021</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2021/03/31/hello-again/" rel="bookmark" title="Hello Again" itemprop="url">Hello Again</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>时间过得快，距离上次更新文章已有7年。弹指一挥间。中断并非本意，而是7年前吃了一堑，想继续更新费点儿劲儿，又忙于其他，于是搁置了。</p>

<p>7年前，电脑丢了，很多资料、code，都没有push到远端，找不回来了。这个博客是用当时较为流行的Octopress搭建的。静态网站放在Github Pages。静态网站部分都还在，但文章markdown原始版本也遭遇丢失。吃一堑长一智，从那之后我倒是记住了，<strong>code不隔夜，都上云。此外电脑也经常用Time Machine备份。</strong></p>

<p>这次得以重新开始更新，经历了4步：</p>

<ul>
<li>Step 1，有想分享的东西，也有点时间，决定重新上路。</li>
<li>Step 2，选平台工具。可选的有微信公众号，简书，或者还是自己搭建。选自己搭建吧，因为目标也不是要触达多少人，还是满足自己乐趣为主。Octopress已经过时很久了，几年前就不再维护了，但有这么个蛋碴子在，给它续上，也是乐趣。所以没有选择用新的工具。</li>
<li>Step 3，恢复文章原始markdown版本。用了pandoc的ruby版，把文章从静态网站的html转为markdown。gist：<a href="https://gist.github.com/Seanli2013/f1e5608fd6f3591d4ddf57bc945ded87">https://gist.github.com/Seanli2013/f1e5608fd6f3591d4ddf57bc945ded87</a></li>
<li>Step 4，重建Octopress+Github Pages。换了个Theme，换一换心情。<a href="http://octopress.org/docs/">http://octopress.org/docs/</a></li>
</ul>


<p>读7年前的东西，真会感觉后背发凉。非常初级和稚嫩。可惜没办法，那就是真实的自己。这7年，非常忙碌，经历颇多，但也在忙碌中忙得碌碌无为。小人物，不甘平庸，追求卓越，保重身体，人生还长，将来还是会做出成绩的。到时候回顾这一路从不堪中摸爬滚打出来，也许会增加些幸福感吧。</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-11-25T07:15:00+08:00">
        <a href="/blog/2013/11/25/animated-gifs-implemented-the-right-way-on-ios/">November 25, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/11/25/animated-gifs-implemented-the-right-way-on-ios/" rel="bookmark" title="iOS播放gif最棒的库，简单高效" itemprop="url">iOS播放gif最棒的库，简单高效</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>iOS 播放 gif最棒的库，简单高效。</p>

<p>Animated GIFs implemented the right way on iOS</p>

<hr />

<p>iOS上播放gif，没有自带的API，所以我找了现成的库，借过来使用。github上我对比了3个star数目较多的代码，最终选择了<a href="https://github.com/ondalabs/OLImageView">OLImageView</a>。</p>

<p>参与对比的是OLImageView，<a href="https://github.com/scspijker/iOS_AnimatedGif">iOS_AnimatedGif</a>，<a href="https://github.com/arturogutierrez/Animated-GIF-iPhone">Animated-GIF-iPhone</a>。</p>

<h3>选择合适的库</h3>

<p>对比的指标，我选择</p>

<h5>1. 效率高，占用内存小</h5>

<p>只播放同样一个Gif，OLImageView占用内存是后两者的4/5。</p>

<p>（这个测试可能不完备，没有测试同时播放多个gif，或者播放不同类型gif的对比。但对我使用来讲，只播放这个Gif，就可以说明问题了。）</p>

<h5>2. 代码维护活跃</h5>

<p>OLImageView近来都有更新。</p>

<p>后两个中，Animated-GIF-iPhone是从iOS_AnimatedGif分出来的，两个都已经分别3年多、1年多没有更新了，虽然去年iOS_AnimatedGif的作者在blog上说要做对ARC的支持，但也没看更新。</p>

<h3>OLImageView用法</h3>

<p>大家可以在github上，看到<a href="https://github.com/ondalabs/OLImageView">OLImageView</a>的用法，用法是描述如何从code中创建和使用，非常简单直白。</p>

<p>我在这里介绍一下实际在Storyboard中使用的方式。</p>

<h5>1. 文件拖入工程</h5>

<p>下载的OLImageView文件共有6个，但只要把下面四个文件拖进你的工程即可：</p>

<p><img src="http://bigbelldev.com/images/blogs/OLImageViewFilesInProject.png" alt="OLImageViewFilesInProject" /></p>

<h5>2. Storyboard中设置UIImageView为OLImageView</h5>

<p>正常拖入一个UIImageView，在这个view的CustomClass中设定为OLImageView：</p>

<p><img src="http://bigbelldev.com/images/blogs/CustomClass.png" alt="CustomClass" /></p>

<p>在Outlet中，设定为OLImageView类型</p>

<p><img src="http://bigbelldev.com/images/blogs/Outlet.png" alt="Outlet" /></p>

<h5>3. code中操作</h5>

<p>在合适的地方，把gif设定进去，注意这里的UIImage要换成OLImage：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>    [self.guideImageGif1 setImage:[OLImage imageNamed:@&quot;peaceful.gif&quot;]];//注意这里的image要使用OLImage</code></pre></td>
</tr>
</tbody>
</table>


<p>我的gif是在scrolllView中播放，所以我还需要设定frame：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>    [self.guideImageGif1 setFrame:self.myScrollView.frame];</code></pre></td>
</tr>
</tbody>
</table>


<h3>效果</h3>

<p>我在“药提醒你”的帮助VC中，背景是个gif，具体效果，你可以下载个下来看看^_^——右侧侧边栏“我的产品”。</p>

<h3>最后</h3>

<p>要是有时间，你尽量阅读一下库的代码。知其然也知其所以然。</p>

<p>我在这里也就写写用法，比较浅显。目的是能让有同样需求的同学，减少一点儿时间开销，哪怕只减少了几分钟，也值得了。</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-11-24T18:10:00+08:00">
        <a href="/blog/2013/11/24/change-tab-on-button-click/">November 24, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/11/24/change-tab-on-button-click/" rel="bookmark" title="点击button实现Storyboard中TabBar Controller的tab切换" itemprop="url">点击button实现Storyboard中TabBar Controller的tab切换</a>
    </h1>
  
</header>

<div class="entry-content">
  <h3>环境和想要实现的功能</h3>

<p>在Storyboard上，TabBarController作为rootViewController，此时想要在某个tab的VC中，点击个button，跳转到另外的tab上。如下图所示：</p>

<p><img src="http://bigbelldev.com/images/blogs/change_tab_vc_on_button.png" alt="" /></p>

<p>上图中，在第一个Tab上，点击“点击此处，去新建和管理提醒”，会跳转到第二个Tab，显示全部提醒的列表，来新建和管理提醒。</p>

<h3>实现代码：</h3>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2</code></pre></td>
<td class="code"><pre><code>    AppDelegate *thisAppDelegate = [[UIApplication sharedApplication] delegate];
    [(UITabBarController *)thisAppDelegate.window.rootViewController setSelectedIndex:1];</code></pre></td>
</tr>
</tbody>
</table>


<p>分析：
我们在用代码创建app的时候，要在appDelegate中，去指定rootViewController。【不熟悉代码创建app的同学可以阅读这篇<a href="http://bigbelldev.com/blog/2013/07/25/ios-gui-implementation-discuss/">学习使用code实现iOS界面</a>，在这篇blog中，推荐的<a href="http://www.cocoachina.com/bbs/read.php?tid=131516">IOS开发之纯代码界面—基本控件使用篇</a>，非常适合新手学习code实现界面】在用Storyboard创建app的时候，虽然不用我们自己去指定rootViewController，但原理是一样的。</p>

<p>Storyboard中，app的入口箭头指向的VC，通常就是rootViewController。在这个例子中，就是UITabBarController。</p>

<p>通过</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>[[UIApplication sharedApplication] delegate]</code></pre></td>
</tr>
</tbody>
</table>


<p>得到自己这个appDelegate，通过调用</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>(UITabBarController *)thisAppDelegate.window.rootViewController</code></pre></td>
</tr>
</tbody>
</table>


<p>就得到了这个UITabBarController（的实例）。再使用UITabBarController（的实例）方法setSelectedIndex，去设定，要跳转到哪个Tab。</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>[(UITabBarController *)thisAppDelegate.window.rootViewController setSelectedIndex:1]</code></pre></td>
</tr>
</tbody>
</table>


<p>就是跳转到index为1的Tab，也就是第二个Tab了。</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-11-21T20:26:00+08:00">
        <a href="/blog/2013/11/21/call-storyboard-scene-programmatically/">November 21, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/11/21/call-storyboard-scene-programmatically/" rel="bookmark" title="通过代码调用Storyboard中的scene —— Call Storyboard Scene Programmatically" itemprop="url">通过代码调用Storyboard中的scene —— Call Storyboard Scene Programmatically</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>通过Storyboard搭建app框架，以及设计和实现一些view
controller和view，是非常方便和高效的。</p>

<p>有时，同样一个scene(i.e. view
controller)，除了在Storyboard上通过segue达到以外，还需要在代码的某个地方，让它展现出来。</p>

<p>如何在代码中，调用一个已经在storyboard中设计好的scene呢？代码如下：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5</code></pre></td>
<td class="code"><pre><code>NSString * storyboardName = @&quot;MainStoryboard_iPhone&quot;;
NSString * viewControllerID = @&quot;ViewID&quot;;
UIStoryboard * storyboard = [UIStoryboard storyboardWithName:storyboardName bundle:nil];
MyViewController * controller = (MyViewController *)[storyboard instantiateViewControllerWithIdentifier:viewControllerID];
[self presentViewController:controller animated:YES completion:nil];</code></pre></td>
</tr>
</tbody>
</table>


<p>注：代码段来自<a href="http://stackoverflow.com/questions/10522957/call-storyboard-scene-programmatically-without-needing-segue">Call storyboard scene programmatically (without needing
segue)?</a></p>

<h5>有两个注意的地方：</h5>

<ol>
<li>上面代码中的storyboardName不要包括”.storyboard”后缀。即，如果你的Storyboard文档叫做“Main.storyboard”，那么storyboardName应该叫@“Main”</li>
<li>注意：在Storyboard中，先给你的viewController加上ID，添加的地方如下图所示：在Indentity中的Storyboard
ID。通过这个viewControllerID（图中的例子就是@“UserGuide”），在代码中找到这个vc。</li>
</ol>


<p><img src="http://bigbelldev.com/images/blogs/storyboardID.png" alt="storyboardID" /></p>

<hr />

<p>关键字：代码中调用storyboard中的vc，代码中present storyboard scene</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-11-20T16:36:00+08:00">
        <a href="/blog/2013/11/20/nsuserdefault-detect-app-first-run-and-propty-settings/">November 20, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/11/20/nsuserdefault-detect-app-first-run-and-propty-settings/" rel="bookmark" title="NSUserDefault 常用功能 检测应用（或app的某个版本）第一次运行 或 记录用户设定的属性”" itemprop="url">NSUserDefault 常用功能 检测应用（或app的某个版本）第一次运行 或 记录用户设定的属性”</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>NSUserDefault，从名称也可看出，一般用来记录用户的设置的。这里介绍两种常用场景：<strong>检测应用（或app的某个版本）第一次运行</strong>
和 <strong>记录用户设定的属性</strong>。</p>

<h3>原理</h3>

<p>几句话说下我的理解：</p>

<ol>
<li>NSUserDefault使用方法standardUserDefaults得到全局的一个<a href="http://bigbelldev.com/blog/2013/07/25/singleton/">单例</a></li>
<li>在这个单例是个dictionary，即通过key-object来存、取信息</li>
<li>信息会存在plist文件中，你不删它，它就一直存在</li>
</ol>


<h3>检测app第一次运行</h3>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5
6
7
8
9</code></pre></td>
<td class="code"><pre><code>    // 以下这段代码，检查是否app的这个版本是否是第一次运行
    NSString *bundleVersion = [[NSBundle mainBundle] objectForInfoDictionaryKey:(NSString *)kCFBundleVersionKey];
    NSString *appFirstStartOfVersionKey = [NSString stringWithFormat:@&quot;first_start_%@&quot;, bundleVersion];
    NSNumber *alreadyStartedOnVersion = [[NSUserDefaults standardUserDefaults] objectForKey:appFirstStartOfVersionKey];
    if(!alreadyStartedOnVersion || [alreadyStartedOnVersion boolValue] == NO) {
        [self versionFirstStart];// app的bundleVersion这个版本第一次运行，你希望这时做点儿什么
        [[NSUserDefaults standardUserDefaults] setObject:[NSNumber numberWithBool:YES] forKey:appFirstStartOfVersionKey];
    }
}</code></pre></td>
</tr>
</tbody>
</table>


<p>每次启动app时候，调用这段代码。检查一个叫做first_start_加版本号这么个key，对应的NSNumber类型Object，是否存在，或是否是0（NO），如果不存在，或者是0（NO），那么是这个版本的第一次运行，这时做你想在app第一次运行时做的事儿，比如[self
versionFirstStart]，之后在plist中添加这个key对应的NSNumber类型object，设置成1（YES）。这样，以后app只要未改变版本，启动时就再也不会执行[self
versionFirstStart]了。</p>

<p><a href="http://stackoverflow.com/questions/7758775/detecting-the-first-ever-run-of-an-app/7758850#7758850">参见stackoverflow</a></p>

<p>P.S.
虽然我并未更改这段代码进行更多尝试，但肯定不一定非要NSNumber这个类型，只要plist能存储和读取的类型就可以。</p>

<h3>记录用户设定的属性</h3>

<p>想设定一个属性，你给这个属性起个独有的key，比如叫做@“your property
key”。</p>

<p>设置属性：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>[[NSUserDefaults standardUserDefaults] setObject:@&quot;off&quot; forKey:@&quot;your property key&quot;];</code></pre></td>
</tr>
</tbody>
</table>


<p>读取和判断属性：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3</code></pre></td>
<td class="code"><pre><code>if([[[NSUserDefaults standardUserDefaults] objectForKey:@&quot;your property key&quot;] isEqualToString:@&quot;off&quot;])
{
}</code></pre></td>
</tr>
</tbody>
</table>


<h3>更多你要了解的NSUserDefault</h3>

<h5>1. 可存储的类型</h5>

<p>NSUserDefault中存储的object的格式只能是以下列表中的类型，这是plist存储方式决定的。</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5
6
7</code></pre></td>
<td class="code"><pre><code>array
dictionary
data
date
number - integer
number - floating point
Boolean</code></pre></td>
</tr>
</tbody>
</table>


<p>了解更多，可查阅<a href="https://developer.apple.com/library/mac/documentation/cocoa/Conceptual/PropertyLists/Introduction/Introduction.html#//apple_ref/doc/uid/10000048i">Property List Programming
Guide</a></p>

<h5>2. 自动存储</h5>

<p>使用NSUserDefault，默认是自动存储的，即你修改完之后，ios自动找个时候，同步（synchronize）一下内存和plist。</p>

<p>手动存储可直接调用synchronize方法：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>[[NSUserDefaults standardUserDefaults] synchronize];</code></pre></td>
</tr>
</tbody>
</table>


<h5>3. 查看目前NSUserDefaults standardUserDefaults中的内容</h5>

<p>查看全部dict内容</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>NSLog(@&quot;%@&quot;, [[NSUserDefaults standardUserDefaults] dictionaryRepresentation]);</code></pre></td>
</tr>
</tbody>
</table>


<p>当然，也可以查看全部的key</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>NSLog(@&quot;%@&quot;, [[[NSUserDefaults standardUserDefaults] dictionaryRepresentation] allKeys]);</code></pre></td>
</tr>
</tbody>
</table>




  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-11-13T10:17:00+08:00">
        <a href="/blog/2013/11/13/outlook-move-ost-location/">November 13, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/11/13/outlook-move-ost-location/" rel="bookmark" title="Outlook 转移OST数据文件 IMAP账户" itemprop="url">Outlook 转移OST数据文件 IMAP账户</a>
    </h1>
  
</header>

<div class="entry-content">
  <h3>问题</h3>

<p>windows8系统，装了Outlook2013，占用了C盘大约10G空间，主要都是数据文件（OST文件）占用的。希望能够把数据文件从C盘移至其他盘。并且账户是IMAP账户，不是Exchange。</p>

<p>google一下，绝大多数解决方案是针对以下两种情况：</p>

<ul>
<li>使用Exchange的账户，如何做到移动ost文件</li>
<li>移动pst文件，而不是移动ost文件</li>
</ul>


<p>都不适用。后来发现了这个解决方案，尝试后，成功！分享给大家：</p>

<h3>解决方案</h3>

<p>把ost文件移动到其他盘，在原来C盘的ost文件位置建立一个链接，链接到移动后的那个文件，大功告成。引用原作者的描述：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5
6
7
8
9
10
11</code></pre></td>
<td class="code"><pre><code>在Outlook2013 IMAP账户中

假设你目前的demo.pst文件在路径C:\Users\%username%\AppData\Local\Microsoft\Outlook下(已创建)

1. 关闭Outlook，移动此文件到D:\Outlook Files下。

2. 打开CMD，键入 mklink &quot;C:\Users\%username%\AppData\Local\Microsoft\Outlook\XXXX.com.ost&quot; &quot;E:\Profile\Outlook\XXXX.com.ost&quot;

3. 此时C:\Users\%username%\AppData\Local\Microsoft\Outlook下会有一个类似于快捷方式的同步文件demo.ost存在（0KB）。

4. 打开Outlook，IMAP账户仍然会挂接到C:\Users\%username%\AppData\Local\Microsoft\Outlook\demo.ost上，但该文件只是D盘下数据文件的映射，实际不消耗任何磁盘空间。</code></pre></td>
</tr>
</tbody>
</table>


<p>原文地址：<a href="http://beijing-zhanglei.blog.sohu.com/272769443.html">Outlook2013
迁移OST存储位置</a></p>

<h3>注意事项</h3>

<p>使用的过程中有需要注意的地方：</p>

<h5>1~ 需要使用管理员身份运行cmd</h5>

<p>windows8的应用程序那儿，搜素cmd，出来“命令提示符”，右键点击，这时屏幕下方会出现几个选项，选择“”以管理员身份运行”</p>

<h5>2~ 建立符号链接的位置的磁盘应该是NTFS格式</h5>

<p>建立符号链接的位置，就是mklink后紧跟的参数的位置，如果不是NTFS格式的盘，恐怕就建立不了了。</p>

<h3>P.S. 我更喜欢Mac</h3>

<p>虽然windows是个很伟大的系统，并且其中的很多软件也异常优秀，但我已经很久不用windows了。日常使用，我觉得Mac系统是胜过windows的，尤其是对编程写代码的人。</p>

<p>但windows你也得熟悉，一方面由于别人的或公共的电脑windows占比很高，另一方面老婆向你求助的时候，你得帮忙解决问题啊，就像今天这个分享写的这事儿。</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-10-28T20:04:00+08:00">
        <a href="/blog/2013/10/28/ios-arc/">October 28, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/10/28/ios-arc/" rel="bookmark" title="iOS ARC入门" itemprop="url">iOS ARC入门</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>现在，iOS系统已经发展到iOS7，而iOS5时引入的ARC技术早已成为主流了。所以iOS新手们对ARC技术已经习以为常了吧，对之前的手工内存管理可能完全不了解，因为基本用不到。ARC又是如此简单，貌似也没有什么必须学习的。但了解一下ARC的原理原则还是必须的——因为了解技术的原理可以更好地对技术进行应用嘛。</p>

<p>本文算是阅读 <a href="http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1">Beginning ARC in iOS 5 Tutorial Part
1</a>
（翻译在 <a href="http://www.raywenderlich.com/zh-hans/20855/ios-5-arc-%E5%85%A5%E9%97%A8-13">iOS 5 ARC 入门
(1/3)</a>
翻译的同学很有爱也很辛苦，但有些地方有错误，所以读原文会比较好。）</p>

<h2>ARC简介</h2>

<p>ARC，Automatic Reference Counting，在iOS5引入。</p>

<h3>原理</h3>

<p>简单说是代码在编译阶段，由编译器（LLVM
3.0）自动生成实例的引用计数管理的一些代码（插入retain/release等），起到内存管理的作用。</p>

<h3>在ARC之前</h3>

<p>在ARC之前，需要手工管理内存，原则是：</p>

<ul>
<li>如果你想保持一个对象可用，除非它已经被retain了，否则就需要retain它</li>
<li>如果不再需要一个对象，就需要release它，除非它已经被release了（通过autorelease）</li>
</ul>


<h3>用ARC，程序会变慢吗？</h3>

<p>不会！</p>

<p>ARC就是在需要retain和release的地方为你插入它们——这就是ARC和手工管理内存一样快的原因，当然有时ARC还会更快，因为它在后端还进行了一些优化操作。</p>

<h2>ARC使用</h2>

<p>这里只介绍个ARC使用方法的小子集，即仅记录了我觉得有意思的几个概念原则。ARC使用全集请看<a href="http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1">Beginning
ARC in iOS 5 Tutorial Part
1</a><sup><a href="#fn:1">1</a></sup>。</p>

<h3>strong、weak</h3>

<ul>
<li>有strong指针指向那个对象，那个对象就一直存在在内存中。这个原则对实例变量、属性、局部变量都使用</li>
<li>默认所有实例变量局部变量等都是strong的指针，strong表示指针是变量的所有者</li>
<li>weak也可以指向一个对象，但不能是所有者</li>
<li>zeroing
weak指针，是指weak指向的对象被释放了，weak指向的变量的值自动变为nil，这个特性防止了指向一个被释放的内存（例如悬空指针、僵尸等这样的说法这种问题就没有啦）</li>
<li>weak不常用，经常使用在父子对象上，因为父有strong指向子，子指向父的时候就只能用weak，常见的datasource、delegate都是这样</li>
</ul>


<h3>ARC特殊注意的地方</h3>

<ul>
<li>ARC不适用于Core Foundation 或 malloc() 和
free()，后者还是要手工管理内存</li>
<li>ARC
有效的时候，由于编译器帮我们做了内存管理的工作，所以我们不需要太担心。但是当与
ARC
管理以外的对象类型交互的时候，就需要特殊的转型关键字，来决定所有权的归属问题。比如“__bridge”。进一步了解可阅读参考文件<sup><a href="#fn:2">2</a></sup></li>
<li>使用ARC，仍然要想着谁持有谁，后者的生命周期是怎么样的等，因为如果不释放指针，被持有者就一直在内存中</li>
</ul>


<h2>结语</h2>

<p>易飞扬对ARC的7篇博文很值得推荐，大家想深入了解ARC原理可以去阅读：
<a href="http://www.yifeiyang.net/development-of-the-iphone-simply-7/">iPhone开发之深入浅出</a>，注：要跳墙。</p>

<p>参考文献<a href="http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1">Beginning ARC in iOS 5 Tutorial Part
1</a>中说：ARC是代表着OC的未来（大概因为ARC之前的内存管理是开发者们曾经的噩梦吧）。A
smart developer tries to automate as much of his job as possible, and
that’s exactly what ARC offers: automation of menial programming work
that you had to do by hand previously. To me, switching is a no-brainer.</p>

<p>技术在不断飞速演进，做工程开发的我们，紧盯技术发展趋势，勇于接受新的东西。</p>

<hr />

<ol>
<li><p><a href="http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1">Beginning ARC in iOS 5 Tutorial Part
1</a><a href="#fnref:1">↩</a></p></li>
<li><p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-7/">iPhone开发之深入浅出</a>
注：该文需要跳墙<a href="#fnref:2">↩</a></p></li>
</ol>


  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-10-24T18:24:00+08:00">
        <a href="/blog/2013/10/24/iwork-free/">October 24, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/10/24/iwork-free/" rel="bookmark" title="老旧Mac如何免费获得iWork" itemprop="url">老旧Mac如何免费获得iWork</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>iWork免费了！以前仰望着的128元的产品，现在终于可以免费使用了！不过，据说需要买最新的硬件才能享受免费。于是就有了下面：老旧mac得到免费iWork的方式。</p>

<p>注：<strong>第二步中可能需要你有美国账号</strong>（其他国家的账号没试过，中国的不行），如果没有美国账号，据说更改系统的语言为英文也行。</p>

<h1>第一步，装个09年的trial版</h1>

<p>下载地址可以去<a href="http://pan.baidu.com/s/1cLWWT">这里</a></p>

<h2>安装可能遇到的问题</h2>

<h3>无法open安装包</h3>

<p>双击安装时，出现下面的对话框：</p>

<p><img src="http://bigbelldev.com/images/tools/iWorkFree/CannotOpen.png" alt="CannotOpen" /></p>

<h3>解决方式</h3>

<p>不双击，而是按住Control键，单击。此时在出现的菜单中选择open。</p>

<p><img src="http://bigbelldev.com/images/tools/iWorkFree/ControlClick.png" alt="ControlClick" /></p>

<p>此时再选择open，就可以啦！</p>

<p><img src="http://bigbelldev.com/images/tools/iWorkFree/ChooseOpenAgain.png" alt="ChooseOpenAgain" /></p>

<p>安装完成后进入第二步。</p>

<h1>第二步，在App Store进行免费更新</h1>

<h2>1. 打开App Store切换国家</h2>

<p>在AppStore页面右下角，有当前国家的标志，点击这里进行切换。点击选择美国后，App
Store市场切换到美国：</p>

<p><img src="http://bigbelldev.com/images/tools/iWorkFree/ChangeCountry.png" alt="ChangeCountry" /></p>

<p>“128元”的标志不见了，取而代之的是“update”。这时需要你的美国账号了。（没有美国账号的同学试试把系统语言改为英文，据说也行）
<img src="http://bigbelldev.com/images/tools/iWorkFree/CanUpdateNow.png" alt="CanUpdateNow" /></p>

<p>选择update，输入美国账号，搞定！</p>

<hr />

<p>苹果公司让这些产品免费，真挺好，赞一个！</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-10-23T20:05:00+08:00">
        <a href="/blog/2013/10/23/ios7-auto-layout/">October 23, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/10/23/ios7-auto-layout/" rel="bookmark" title="iOS7 Autolayout 瞬间入门！" itemprop="url">iOS7 Autolayout 瞬间入门！</a>
    </h1>
  
</header>

<div class="entry-content">
  <p>Autolayout是非常先进的一个技术。使用这种技术，适应不同设备屏幕大小差异或设备翻转时对界面的要求，变得很容易。这种技术提供了一种灵活的机制来描述界面上各控件的位置关系。</p>

<p>Xcode5使Autolayout技术更容易使用了。
之前，我对Autolayout只是听说有这种机制，但不知原理、用法。于是阅读了下面的两篇文章（作者：
Matthijs Hollemans。目前貌似还没有翻译），算是在Storyboard/Xib上会用了。</p>

<ul>
<li><a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">Beginning Auto Layout Tutorial in iOS 7: Part
1</a></li>
<li><a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">Beginning Auto Layout Tutorial in iOS 7: Part
2</a></li>
</ul>


<p>以下作为阅读笔记，记录应该了解的使用Autolayout的要点(环境是Xcode5，iOS7SDK，Storyboard/Xib)。</p>

<h1>原理要点</h1>

<ul>
<li>Autolayout基本是靠constraints来描述两个view之间的位置关系</li>
<li>Autolayout与以往的frame、bound、center包括autosizing
mask等方式都不同，这是一个新的技术，使用Autolayout时候就不用考虑以上那些方式啦，不用再纠结这个view的位置是(x,y,width,height)了！</li>
<li>Autolayout描述位置关系的这两个view，或者是上下层关系，或者是同一层关系。即父子关系或都是父的子（兄弟关系^_^）</li>
<li>Constraints都是NSLayoutConstraint的对象，有一些属性可以在Attributes
inspector中修改。当然也可以通过code的方式来实现Storyboard/Xib上的操作</li>
</ul>


<h1>使用方式</h1>

<p>这里只介绍Storyboard/Xib使用方式，如果想了解code实现，还要继续阅读其他资料。</p>

<h3>设计及实现方法：</h3>

<p>理清view想要摆放的位置逻辑（设计），根据这个逻辑来设置Constraints（实现）。比如这个Button要距离那个Button固定20个点的距离，并且两个Button要顶端对齐等。把这些逻辑条件变成constraints，当constraints完备到可以确定view的位置时，就完成了设计和实现。</p>

<h3>在Storyboard/Xib上使用</h3>

<ul>
<li><p>Autolayout的checkbox默认是check上的，这个配置是对整个Storyboard或整个Xib生效的</p></li>
<li><p>可以设置Constraints的地方</p>

<p>1 Editor菜单下的Pin以上的4个菜单</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/StrutsProblem-pin-widths-equally.png" alt="Editor" /></p>

<p>2 在View层次列表中选中Constraints后，在Attributes Inspector中设置</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/Equal-widths-in-document-outline.png" alt="viewhierachy" />
<img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/Tango-vertical-space-attributes.png" alt="Inspector" /></p>

<p>3 最方面快捷的方式是在悬浮在界面编辑右下角的几个图标</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/Auto-Layout-buttons.png" alt="quick
menu" /></p></li>
<li><p>蓝色的辅助线：表明Constraints已经足以说明这个view的位置了</p></li>
</ul>


<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/Tango-left-align-constraint.png" alt="blue" /></p>

<ul>
<li>橙色的辅助线：表示constraints没有完备到可以说明这个view的位置</li>
</ul>


<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/Tango-badge-on-V-space.png" alt="orange" /></p>

<ul>
<li><p>橙色的辅助线上的数字：有时是正数，有时是负数。当你设定或更改了Constraints的时候，可能Constraints与界面上你放置的view的位置是不同的。系统会以Constraints为准，界面上提示你橙色辅助线，线上的数字是这个view的位置与Constraints的差距。这时可以在“Resolve
Auto Layout Issues”中选择update
frame，这样这个view会自动移动到Constraints所指示的地方；也可以update
constraints，这时view的位置不变，constraints变为与界面上的view位置一致的数值</p></li>
<li><p>对没有提供Constraints的view，系统会自动加上constraints，这些constraints是界面上不可见的。这一点是Xcode5与Xcode4在Autolayout技术升级上最大的改进！Xcode4是系统强加constraints，往往会对开发者进行了干扰，因为强加的Constraints往往不是你想要的。Xcode5的这个改进方便了开发者按照自己的意图去设计和实施：首先不用去修改系统强加的constraints；其次有些view的位置你不需要增加Constraints，就可以不用理会。注：这种自动给View加Constraints的方式只适用于你一个Constraints都没加的情况，如果你加了x方向的，y方向的也需要手动添加。</p></li>
<li><p>preview：preview可真方便，你一边在左侧（Portrait、4寸屏）设计实施，一边在preview中看到lanscape的样子或者在3.5寸屏中的样子</p></li>
</ul>


<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/Storyboard-preview.png" alt="preview" /></p>

<ul>
<li>可设置的constraints的类别：

<ol>
<li>几个View之间对齐

<ul>
<li>边缘对齐、中心对齐等</li>
<li>这几个view宽、高相等等</li>
</ul>
</li>
<li>相对距离。

<ul>
<li>距离最近的一个view的距离</li>
<li>两个view之间的距离</li>
<li>距离顶端、底端、左边缘、右边缘的距离</li>
<li>自己的宽、高</li>
</ul>
</li>
</ol>
</li>
</ul>


<h1>接下来</h1>

<p>以上是一些基础要点，当你用Storyboard/Xib做设计的时候，基本就够用啦。如果觉得这些要点不够，可以参照Matthijs
Hollemans在这两篇文章中举的例子，这个例子将带你进行一步步操作。</p>

<p>有些特殊的场景，使用Storyboard/Xib的autolayout是无法实现，需要代码方式的autolayout来实现。代码实现主要围绕着对NSLayoutConstraint对象的操作。具体如何实现，等需要的时候再找时间研究了。</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2013-10-12T22:36:00+08:00">
        <a href="/blog/2013/10/12/tableviewcell-superview-changed-on-ios7-sdk/">October 12, 2013</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About 大钟威武">大钟威武</a>
      </span>
    </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2013/10/12/tableviewcell-superview-changed-on-ios7-sdk/" rel="bookmark" title="UITableViewCell在iOS7之后superview的问题" itemprop="url">UITableViewCell在iOS7之后superview的问题</a>
    </h1>
  
</header>

<div class="entry-content">
  <h3>在UITableView中针对某个Cell的操作</h3>

<p>要针对某个UITableView中的Cell做些操作，比如对这个Cell的内容进行查看详细、编辑、删除、或者触发其他功能比如发短信、打电话等，删除、和点击这个Cell在UITableView的Delegate方法中提供，其他的操作就需要识别Cell上的控件（比如Button）对应的action是针对这个Cell的。</p>

<p>一种常用的方式是使用view的层次，在action中找到这个Cell：在</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code></pre></td>
</tr>
</tbody>
</table>


<p>方法中，把这个Cell的Button加入到Cell的contentView的subView，并且为这个button添加Target。</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3</code></pre></td>
<td class="code"><pre><code>// Button 操作
[cell.contentView addSubview:cell.button];
[cell.button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];</code></pre></td>
</tr>
</tbody>
</table>


<p>之后在对应的</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>- (void)buttonAction:(id)sender</code></pre></td>
</tr>
</tbody>
</table>


<p>action中，通过view的层次，去找到对应的Cell：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5
6
7
8</code></pre></td>
<td class="code"><pre><code>// iOS7 之前
- (void)editRemindAction:(id)sender
{
    UIButton *button = (UIButton *)sender;
    UITableViewCell *cell = (UITableViewCell *)[[button superview] superview];
    NSIndexPath *indexPath = [self.tableView indexPathForCell:cell];
  // 继续其他的处理
}</code></pre></td>
</tr>
</tbody>
</table>


<h3>iOS7之后出的问题</h3>

<p>在iOS7之后，这样的办法会报错，错误在通过</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>UITableViewCell *cell = (UITableViewCell *)[[]button superview] superview];</code></pre></td>
</tr>
</tbody>
</table>


<p>的方式，得到的不是cell，所以在这行以下用到cell的地方，就会抛出异常。</p>

<p>原因是在iOS7中，在 UITableViewCell 和
UITableViewCell的ContentView之间，还有一个UITableViewCellScrollView，所以通过两次superview往上“爬”，是爬不到UITableViewCell的。</p>

<h3>解决方式</h3>

<p>直观地看，就是向上爬三次superview就行了。为了更好地处理这个问题，应该建立一个UIView的Category（因为这里使用的view的层次superview是UIView的方法），写个Category方法来区分不同情况来得到Cell：</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</code></pre></td>
<td class="code"><pre><code>@implementation UIView (GetCellFromContentviewSubview)
- (UITableViewCell *)getCellFromContentviewSubview
{
    if ([[[self superview] superview] isKindOfClass:[UITableViewCell class]]) {
        return (UITableViewCell *)[[self superview] superview];
    }
    else if ([[[[self superview] superview] superview] isKindOfClass:[UITableViewCell class]]) {
        return (UITableViewCell *)[[[self superview] superview] superview];
    }
    else{
         NSLog(@&quot;Something Panic Happens&quot;);
    }
    return nil;
}
@end</code></pre></td>
</tr>
</tbody>
</table>


<p>之后，把</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>UITableViewCell *cell = (UITableViewCell *)[[button superview] superview];</code></pre></td>
</tr>
</tbody>
</table>


<p>替换成</p>

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td class="gutter"><pre class="line-numbers"><code>1</code></pre></td>
<td class="code"><pre><code>UITableViewCell *cell = (UITableViewCell *)[button getCellFromContentviewSubview];</code></pre></td>
</tr>
</tbody>
</table>


<p>就可以了。</p>

<h3>讨论</h3>

<p>另外一种办法是给控件的tag附上indexPath.row，之后在action中通过tag来得到对应的cell，但如果Cell不是静态的，indexPath.row是会变的。所以这不是一个好的办法。</p>

<p>但我所提供的这个办法，在stackoverflow上有1人给vote
down，不知道为什么被vote down。这种办法有什么问题吗？</p>

  
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->


<div class="pagination">
  
  <a href="/archives">Blog Archives</a>
  
    <a href="/posts/2" class="btn">Next</a>
  
</div><!-- /.pagination -->

  </div><!-- /#main -->

  <div class="footer-wrapper">
    <footer role="contentinfo">
      <span>&copy; 2021 大钟威武. Powered by <a href="http://octopress.org">Octopress</a> using the <a href="https://github.com/jez/hpstr-theme/">HPSTR Theme for Octopress</a>.</span>

    </footer>
  </div><!-- /.footer-wrapper -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/javascripts/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>
<script src="/javascripts/scripts.min.js"></script>




          
  

</body>
</html>
